<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUCK NO</title>
    <link rel="stylesheet" href="rageroom.css">
    <link rel="icon" type="image/x-icon" href="img/favicon_light.svg">
</head>
<body>
    <div class="marquee-container">
        <a class="marquee-header" href="https://gab333t.github.io/fuckno/">FUCK NO</a>
        <nav class="marquee-nav">
            <a class="marquee-text" href="https://gab333t.github.io/fuckno/about.html"></a>
        </nav>
    </div>

    <div class="error-container" id="error-container">
        <h2 class="body-text error-text">ERROR:<br>Inventory not selected.</h2>
        <button class="start-button" id="return-button">RETURN TO INVENTORY</button>
    </div>

    <div class="tool-selection-container" id="tool-selection">
        <h2 class="body-text">Select your tool.</h2>
        <div class="tool-container">
            <img src="img/rock.webp" alt="Rock icon." data-tool="rock">
            <img src="img/sledgehammer.webp" alt="Sledgehammer icon." data-tool="sledgehammer">
            <img src="img/dynamite.webp" alt="Dynamite icon." data-tool="dynamite">
        </div>
        
        <div class="tool-descriptions">
            <h2 class="body-text tool-description" id="rock-desc">ROCK<br>Deals 3 damage with a 0.1 second cooldown.</h2>
            <h2 class="body-text tool-description" id="sledgehammer-desc">SLEDGEHAMMER<br>Deals 5 damage with a 0.6 second cooldown.</h2>
            <h2 class="body-text tool-description" id="dynamite-desc">DYNAMITE<br>Deals 8 damage with a 1 second cooldown.</h2>
        </div>
    </div>

    <div class="instructions-container" id="instructions-container">
        <h2 class="body-text instructions-text" id="instructions">You're about to destroy the images you've selected as they cycle through a queue.
            You can change the tool during the experience to better accomodate your needs.
            At the end, you'll be ranked based on how long you take and the number of NO's you brought into the RAGE ROOM today.<br><br>
            You'll be starting off with <span id="tool-name"></span>. Don't hold back.
        </h2>
        <button class="start-button" id="start-button">RAGE</button>
    </div>

    <div class="game-container" id="game-container">
        <div class="image-display" id="image-display">
            <img id="current-image" src="" alt="Current NO sign">
            <div class="health-bar-container">
                <div class="health-bar" id="health-bar"></div>
            </div>
        </div>
        
        <div class="game-info">
            <h2 class="body-text info-text">
                <span id="images-remaining">0</span> NO's remaining
            </h2>
        </div>

        <div class="tool-switcher">
            <h2 class="body-text switch-text">Switch tool:</h2>
            <div class="tool-icons">
                <img src="img/rock.webp" alt="Rock" data-tool="rock" class="tool-icon">
                <img src="img/sledgehammer.webp" alt="Sledgehammer" data-tool="sledgehammer" class="tool-icon">
                <img src="img/dynamite.webp" alt="Dynamite" data-tool="dynamite" class="tool-icon">
            </div>
        </div>
    </div>

    <div class="results-container" id="results-container">
        <h2 class="body-text results-title">RAGE ROOM COMPLETE</h2>
        <div class="results-stats">
            <h2 class="body-text stat-text">Time: <span id="final-time">00:00</span></h2>
            <h2 class="body-text stat-text">NO's Destroyed: <span id="final-count">0</span></h2>
            <h2 class="body-text stat-text">Rank: <span id="final-rank">-</span></h2>
        </div>
        <button class="start-button" id="restart-button">RESTART</button>
    </div>

    <div class="bottom-marquee-container">
        <div class="bottom-marquee">
            <span class="marquee-content">RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM</span>
            <span class="marquee-content">RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM</span>
        </div>
    </div>

    <h2 class="timer">00:00</h2>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script>
const TWO_PI = Math.PI * 2;

function setFavicon() {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const faviconPath = isDarkMode ? 'img/favicon_dark.svg' : 'img/favicon_light.svg';

    let favicon = document.querySelector("link[rel='icon']");
    if (!favicon) {
        favicon = document.createElement('link');
        favicon.rel = 'icon';
        document.head.appendChild(favicon);
    }
    favicon.href = faviconPath;
}

function updateAboutText() {
    const aboutLink = document.querySelector('.marquee-text');
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (window.innerWidth <= 550) {
        const imagePath = isDarkMode ? 'img/about_dark.svg' : 'img/about_light.svg';
        aboutLink.innerHTML = `<img src="${imagePath}" alt="About" class="about-icon" draggable="false">`;
    } else {
        aboutLink.textContent = 'ABOUT';
    }
}

setFavicon();
updateAboutText();

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    setFavicon();
    updateAboutText();
});

window.addEventListener('resize', updateAboutText);

let titleIndex = 0;
const titles = ['FUCK NO', 'RAGE ROOM'];
setInterval(() => {
    titleIndex = (titleIndex + 1) % titles.length;
    document.title = titles[titleIndex];
}, 3000);

function getSelectedImages() {
    const urlParams = new URLSearchParams(window.location.search);
    const selected = urlParams.get('selected');
    
    if (selected) {
        return selected.split(',').map(num => parseInt(num));
    }
    
    return null;
}

const selectedImages = getSelectedImages();

if (selectedImages === null) {
    document.getElementById('error-container').classList.add('visible');
    document.getElementById('tool-selection').style.display = 'none';
} else {
    let currentImageIndex = 0;
    let imageQueue = [...selectedImages];
}

const toolImages = document.querySelectorAll('.tool-container img');
let selectedTool = null;
let currentImageIndex = 0;
let imageQueue = selectedImages ? [...selectedImages] : [];
const toolStats = {
    rock: { damage: 3, cooldown: 100 },
    sledgehammer: { damage: 5, cooldown: 600 },
    dynamite: { damage: 8, cooldown: 1000 }
};

function createAudioPool(tool, filename) {
    return [
        `audio/${filename}1.mp3`,
        `audio/${filename}2.mp3`,
        `audio/${filename}3.mp3`
    ];
}

const audioFiles = {
    rock: createAudioPool('rock', 'rock'),
    sledgehammer: createAudioPool('sledgehammer', 'glass'),
    dynamite: createAudioPool('dynamite', 'explode')
};

function playToolSound(tool) {
    const sounds = audioFiles[tool];
    if (sounds) {
        const randomIndex = Math.floor(Math.random() * 3);
        const audioPath = sounds[randomIndex];
        
        const audio = new Audio(audioPath);
        audio.volume = 0.7;
        audio.play().catch(err => {
            console.log(`Audio play failed for ${tool}:`, err);
            console.log('Attempted path:', audioPath);
        });
    }
}

toolImages.forEach(img => {
    const originalSrc = img.src;
    const altText = img.alt;
    const toolType = img.dataset.tool;
    
    img.addEventListener('mouseenter', () => {
        const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const mode = isDarkMode ? 'dark' : 'light';
        
        if (altText.includes('Sledgehammer')) {
            img.src = `img/sledgehammer_${mode}.webp`;
        } else if (altText.includes('Dynamite')) {
            img.src = `img/dynamite_${mode}.webp`;
        } else if (altText.includes('Rock')) {
            img.src = `img/rock_${mode}.webp`;
        }
        
        const description = document.getElementById(`${toolType}-desc`);
        if (description) {
            description.classList.add('visible');
        }
    });
    
    img.addEventListener('mouseleave', () => {
        img.src = originalSrc;
        
        const description = document.getElementById(`${toolType}-desc`);
        if (description) {
            description.classList.remove('visible');
        }
    });

    img.addEventListener('click', () => {
        selectedTool = toolType;
        
        const toolNameSpan = document.getElementById('tool-name');
        if (toolType === 'rock') {
            toolNameSpan.textContent = 'a ROCK';
        } else if (toolType === 'sledgehammer') {
            toolNameSpan.textContent = 'a SLEDGEHAMMER';
        } else if (toolType === 'dynamite') {
            toolNameSpan.textContent = 'DYNAMITE';
        }
        
        document.getElementById('tool-selection').classList.add('hidden');
        document.getElementById('instructions-container').classList.add('visible');
    });
});

let startTime = null;
let timerInterval = null;
const timerElement = document.querySelector('.timer');

function updateTimer() {
    if (!startTime) return;
    
    const elapsed = Date.now() - startTime;
    const seconds = Math.floor(elapsed / 1000);
    const milliseconds = Math.floor((elapsed % 1000) / 10);
    
    const formattedTime = `${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    timerElement.textContent = formattedTime;
}

let currentHealth = 20;
let maxHealth = 20;
let canAttack = true;
let totalDestroyed = 0;

function loadNextImage() {
    if (imageQueue.length === 0) {
        endGame();
        return;
    }
    
    const imageNumber = imageQueue[0];
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = isDarkMode ? 'dark' : 'light';
    
    const currentImage = document.getElementById('current-image');
    currentImage.src = `img/no${imageNumber}_${theme}.webp`;
    currentImage.alt = `NO sign ${imageNumber}`;
    
    currentHealth = maxHealth;
    updateHealthBar();
    updateRemainingCount();
}

function updateHealthBar() {
    const healthBar = document.getElementById('health-bar');
    const percentage = (currentHealth / maxHealth) * 100;
    healthBar.style.width = `${percentage}%`;
}

function updateRemainingCount() {
    document.getElementById('images-remaining').textContent = imageQueue.length;
}

function shakeImage() {
    const img = document.getElementById('current-image');
    const randomX = (Math.random() - 0.5) * 10;
    const randomY = (Math.random() - 0.5) * 10;
    
    img.style.transform = `translate(${randomX}px, ${randomY}px)`;
    
    setTimeout(() => {
        img.style.transform = 'translate(0, 0)';
    }, 100);
}

function setImageCursor() {
    const img = document.getElementById('current-image');
    if (selectedTool) {
        img.style.cursor = `url('img/${selectedTool}_cursor.ico'), auto`;
    }
}

function randomRange(min, max) {
    return min + (max - min) * Math.random();
}

function clamp(x, min, max) {
    return x < min ? min : (x > max ? max : x);
}

function sign(x) {
    return x < 0 ? -1 : 1;
}

let allFragments = [];
const MAX_FRAGMENTS = 200;

function cleanupOldFragments() {
    if (allFragments.length > MAX_FRAGMENTS) {
        const fragmentsToRemove = allFragments.length - MAX_FRAGMENTS;
        
        for (let i = 0; i < fragmentsToRemove; i++) {
            const fragment = allFragments[i];
            if (fragment && fragment.parentNode) {
                fragment.style.transition = 'opacity 0.5s ease-out';
                fragment.style.opacity = '0';
                
                setTimeout(() => {
                    if (fragment.parentNode) {
                        fragment.parentNode.removeChild(fragment);
                    }
                }, 500);
            }
        }
        
        allFragments.splice(0, fragmentsToRemove);
    }
}

function createGlassFragments(imageElement, clickX, clickY) {
    const container = document.getElementById('image-display');
    const rect = imageElement.getBoundingClientRect();
    
    const fragments = [];
    const numFragments = 80;
    
    for (let i = 0; i < numFragments; i++) {
        const fragment = document.createElement('canvas');
        const ctx = fragment.getContext('2d');
        
        const startX = rect.left + randomRange(0, rect.width);
        const startY = rect.top + randomRange(0, rect.height);
        
        const size = randomRange(15, 45);
        const points = [];
        const numPoints = Math.floor(randomRange(3, 6));
        
        for (let j = 0; j < numPoints; j++) {
            const pointAngle = (j / numPoints) * TWO_PI;
            const pointRadius = size * randomRange(0.5, 1);
            points.push({
                x: Math.cos(pointAngle) * pointRadius,
                y: Math.sin(pointAngle) * pointRadius
            });
        }
        
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxY = Math.max(...points.map(p => p.y));
        const width = maxX - minX;
        const height = maxY - minY;
        
        fragment.width = width;
        fragment.height = height;
        fragment.style.width = width + 'px';
        fragment.style.height = height + 'px';
        fragment.style.position = 'fixed';
        fragment.style.pointerEvents = 'none';
        fragment.style.zIndex = '500';
        
        ctx.save();
        ctx.translate(-minX, -minY);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let j = 1; j < points.length; j++) {
            ctx.lineTo(points[j].x, points[j].y);
        }
        ctx.closePath();
        ctx.clip();
        
        const relativeX = startX - rect.left;
        const relativeY = startY - rect.top;
        const imgX = -relativeX - minX;
        const imgY = -relativeY - minY;
        ctx.drawImage(imageElement, imgX, imgY, rect.width, rect.height);
        ctx.restore();
        
        const dx = startX - (rect.left + rect.width / 2);
        const dy = startY - (rect.top + rect.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const velocityX = (dx / Math.max(distance, 1)) * randomRange(100, 250);
        const velocityY = randomRange(-300, -100);
        const rotationSpeed = randomRange(-360, 360);
        
        const gravity = 600;
        const friction = 0.5;
        const groundY = window.innerHeight - height;
        
        let posX = startX;
        let posY = startY;
        let velX = velocityX;
        let velY = velocityY;
        let rotation = randomRange(0, 360);
        let isAnimating = true;
        
        fragment.style.left = posX + 'px';
        fragment.style.top = posY + 'px';
        fragment.style.transform = `rotate(${rotation}deg)`;
        
        const animate = () => {
            if (isAnimating) {
                const deltaTime = 0.016;
                
                velY += gravity * deltaTime;
                
                posX += velX * deltaTime;
                posY += velY * deltaTime;
                rotation += rotationSpeed * deltaTime;
                
                if (posY >= groundY) {
                    posY = groundY;
                    velY = -velY * friction;
                    velX *= friction;
                    
                    if (Math.abs(velY) < 30 && Math.abs(velX) < 30) {
                        isAnimating = false;
                        velY = 0;
                        velX = 0;
                    }
                }
                
                fragment.style.left = posX + 'px';
                fragment.style.top = posY + 'px';
                fragment.style.transform = `rotate(${rotation}deg)`;
                
                if (isAnimating) {
                    requestAnimationFrame(animate);
                }
            }
        };
        
        const delay = randomRange(0, 50);
        setTimeout(() => {
            requestAnimationFrame(animate);
        }, delay);
        
        document.body.appendChild(fragment);
        fragments.push(fragment);
        allFragments.push(fragment);
    }
    
    cleanupOldFragments();
    
    return fragments;
}

let lastClickPosition = { x: 0, y: 0 };

function attackImage(event) {
    if (!canAttack || imageQueue.length === 0) return;
    
    lastClickPosition.x = event.clientX;
    lastClickPosition.y = event.clientY;
    
    const damage = toolStats[selectedTool].damage;
    currentHealth -= damage;
    
    playToolSound(selectedTool);
    shakeImage();
    updateHealthBar();
    
    if (currentHealth <= 0) {
        const img = document.getElementById('current-image');
        createGlassFragments(img, lastClickPosition.x, lastClickPosition.y);
        
        img.style.opacity = '0';
        
        imageQueue.shift();
        totalDestroyed++;
        
        if (imageQueue.length > 0) {
            setTimeout(() => {
                img.style.opacity = '1';
                loadNextImage();
            }, 800);
        } else {
            setTimeout(() => {
                endGame();
            }, 800);
        }
    }
    
    canAttack = false;
    setTimeout(() => {
        canAttack = true;
    }, toolStats[selectedTool].cooldown);
}

function getRank(time, count) {
    const timeInSeconds = time / 1000;
    const avgTimePerImage = timeInSeconds / count;
    
    if (avgTimePerImage < 2) return 'S';
    if (avgTimePerImage < 3) return 'A';
    if (avgTimePerImage < 4) return 'B';
    if (avgTimePerImage < 5) return 'C';
    return 'D';
}

function endGame() {
    clearInterval(timerInterval);
    
    const finalTime = Date.now() - startTime;
    const seconds = Math.floor(finalTime / 1000);
    const milliseconds = Math.floor((finalTime % 1000) / 10);
    const formattedTime = `${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    
    document.getElementById('final-time').textContent = formattedTime;
    document.getElementById('final-count').textContent = totalDestroyed;
    document.getElementById('final-rank').textContent = getRank(finalTime, totalDestroyed);
    
    document.getElementById('game-container').classList.remove('visible');
    document.querySelector('.timer').classList.remove('visible');
    document.querySelector('.bottom-marquee-container').classList.remove('visible');
    document.getElementById('results-container').classList.add('visible');
}

document.getElementById('start-button').addEventListener('click', () => {
    document.querySelector('.timer').classList.add('visible');
    document.querySelector('.bottom-marquee-container').classList.add('visible');
    document.getElementById('instructions-container').classList.remove('visible');
    document.getElementById('game-container').classList.add('visible');
    
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 10);
    updateTimer();
    
    loadNextImage();
    setImageCursor();
});

document.getElementById('current-image').addEventListener('click', attackImage);

document.querySelectorAll('.tool-icon').forEach(icon => {
    icon.addEventListener('click', () => {
        const newTool = icon.dataset.tool;
        selectedTool = newTool;
        
        document.querySelectorAll('.tool-icon').forEach(i => {
            const toolType = i.dataset.tool;
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const mode = isDarkMode ? 'dark' : 'light';
            
            if (i === icon) {
                i.src = `img/${toolType}_${mode}.webp`;
            } else {
                i.src = `img/${toolType}.webp`;
            }
        });
        
        setImageCursor();
    });
});

document.getElementById('restart-button').addEventListener('click', () => {
    window.location.href = 'https://gab333t.github.io/fuckno/';
});

document.getElementById('return-button').addEventListener('click', () => {
    window.location.href = 'https://gab333t.github.io/fuckno/';
});
</script>
</body>
</html>