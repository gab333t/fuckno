<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUCK NO</title>
    <link rel="stylesheet" href="rageroom.css">
    <link rel="icon" type="image/x-icon" href="img/favicon_light.svg">
</head>
<body>
    <div class="marquee-container">
        <a class="marquee-header" href="https://gab333t.github.io/fuckno/">FUCK NO</a>
        <nav class="marquee-nav">
            <a class="marquee-text" href="https://gab333t.github.io/fuckno/about.html"></a>
        </nav>
    </div>

    <div class="error-container" id="error-container">
        <h2 class="body-text error-text">ERROR:<br>Inventory not selected.</h2>
        <button class="start-button" id="return-button">RETURN TO INVENTORY</button>
    </div>

    <div class="tool-selection-container" id="tool-selection">
        <h2 class="body-text">SELECT YOUR TOOL:</h2>
        <div class="tool-container">
            <img src="img/rock.webp" alt="Rock icon." data-tool="rock">
            <img src="img/sledgehammer.webp" alt="Sledgehammer icon." data-tool="sledgehammer">
            <img src="img/dynamite.webp" alt="Dynamite icon." data-tool="dynamite">
        </div>
        
        <div class="tool-descriptions">
            <h2 class="body-text tool-description" id="rock-desc">ROCK<br>Deals 3 damage with a 0.1 second cooldown.</h2>
            <h2 class="body-text tool-description" id="sledgehammer-desc">SLEDGEHAMMER<br>Deals 5 damage with a 0.3 second cooldown.</h2>
            <h2 class="body-text tool-description" id="dynamite-desc">DYNAMITE<br>Deals 8 damage with a 0.5 second cooldown.</h2>
        </div>
    </div>

    <div class="instructions-container" id="instructions-container">
        <h2 class="body-text instructions-text" id="instructions">You're about to destroy the images you've selected as they cycle through a queue.
            You can change the tool during the experience to better accomodate your needs.
            At the end, you'll be ranked based on how long you take and the number of NO's you brought into the RAGE ROOM today.<br><br>
            You'll be starting off with <span id="tool-name"></span>. Don't hold back.
        </h2>
        <button class="start-button" id="start-button">RAGE</button>
    </div>

    <div class="game-container" id="game-container">
        <div class="image-display" id="image-display">
            <img id="current-image" src="" alt="Current NO sign">
            <div class="health-bar-container">
                <div class="health-bar" id="health-bar"></div>
            </div>
        </div>
        
        <div class="game-info">
            <h2 class="body-text info-text">
                <span id="images-remaining">0</span> NO's remaining
            </h2>
        </div>

        <div class="tool-switcher">
            <h2 class="body-text switch-text">Switch tool:</h2>
            <div class="tool-icons">
                <img src="img/rock.webp" alt="Rock" data-tool="rock" class="tool-icon">
                <img src="img/sledgehammer.webp" alt="Sledgehammer" data-tool="sledgehammer" class="tool-icon">
                <img src="img/dynamite.webp" alt="Dynamite" data-tool="dynamite" class="tool-icon">
            </div>
        </div>
    </div>

    <div class="results-container" id="results-container">
        <h2 class="body-text results-title">RAGE ROOM COMPLETE</h2>
        <div class="results-stats">
            <h2 class="body-text stat-text">Time: <span id="final-time">00:00</span></h2>
            <h2 class="body-text stat-text">NO's Destroyed: <span id="final-count">0</span></h2>
            <h2 class="body-text stat-text">Rank: <span id="final-rank">-</span></h2>
        </div>
        <button class="start-button" id="restart-button">RESTART</button>
    </div>

    <div class="bottom-marquee-container">
        <div class="bottom-marquee">
            <span class="marquee-content">RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM</span>
            <span class="marquee-content">RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM</span>
        </div>
    </div>

    <h2 class="timer">00:00</h2>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script>
const TWO_PI = Math.PI * 2;

function setFavicon() {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const faviconPath = isDarkMode ? 'img/favicon_dark.svg' : 'img/favicon_light.svg';

    let favicon = document.querySelector("link[rel='icon']");
    if (!favicon) {
        favicon = document.createElement('link');
        favicon.rel = 'icon';
        document.head.appendChild(favicon);
    }
    favicon.href = faviconPath;
}

function updateAboutText() {
    const aboutLink = document.querySelector('.marquee-text');
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (window.innerWidth <= 550) {
        const imagePath = isDarkMode ? 'img/about_dark.svg' : 'img/about_light.svg';
        aboutLink.innerHTML = `<img src="${imagePath}" alt="About" class="about-icon" draggable="false">`;
    } else {
        aboutLink.textContent = 'ABOUT';
    }
}

setFavicon();
updateAboutText();

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    setFavicon();
    updateAboutText();
});

window.addEventListener('resize', updateAboutText);

let titleIndex = 0;
const titles = ['FUCK NO', 'RAGE ROOM'];
setInterval(() => {
    titleIndex = (titleIndex + 1) % titles.length;
    document.title = titles[titleIndex];
}, 3000);

function getSelectedImages() {
    const urlParams = new URLSearchParams(window.location.search);
    const selected = urlParams.get('selected');
    
    if (selected) {
        return selected.split(',').map(num => parseInt(num));
    }
    
    return null;
}

const selectedImages = getSelectedImages();

if (selectedImages === null) {
    document.getElementById('error-container').classList.add('visible');
    document.getElementById('tool-selection').style.display = 'none';
} else {
    let currentImageIndex = 0;
    let imageQueue = [...selectedImages];
}

const toolImages = document.querySelectorAll('.tool-container img');
let selectedTool = null;
let currentImageIndex = 0;
let imageQueue = selectedImages ? [...selectedImages] : [];
const toolStats = {
    rock: { damage: 3, cooldown: 100 },
    sledgehammer: { damage: 5, cooldown: 300 },
    dynamite: { damage: 8, cooldown: 500 }
};

function createAudioPool(tool, filename) {
    return [
        `audio/${filename}1.mp3`,
        `audio/${filename}2.mp3`,
        `audio/${filename}3.mp3`
    ];
}

const audioFiles = {
    rock: createAudioPool('rock', 'rock'),
    sledgehammer: createAudioPool('sledgehammer', 'glass'),
    dynamite: createAudioPool('dynamite', 'explode')
};

function playToolSound(tool) {
    const sounds = audioFiles[tool];
    if (sounds) {
        const randomIndex = Math.floor(Math.random() * 3);
        const audioPath = sounds[randomIndex];
        
        const audio = new Audio(audioPath);
        audio.volume = 0.7;
        audio.play().catch(err => {
            console.log(`Audio play failed for ${tool}:`, err);
            console.log('Attempted path:', audioPath);
        });
    }
}

toolImages.forEach(img => {
    const originalSrc = img.src;
    const altText = img.alt;
    const toolType = img.dataset.tool;
    
    img.addEventListener('mouseenter', () => {
        const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const mode = isDarkMode ? 'dark' : 'light';
        
        if (altText.includes('Sledgehammer')) {
            img.src = `img/sledgehammer_${mode}.webp`;
        } else if (altText.includes('Dynamite')) {
            img.src = `img/dynamite_${mode}.webp`;
        } else if (altText.includes('Rock')) {
            img.src = `img/rock_${mode}.webp`;
        }
        
        const description = document.getElementById(`${toolType}-desc`);
        if (description) {
            description.classList.add('visible');
        }
    });
    
    img.addEventListener('mouseleave', () => {
        img.src = originalSrc;
        
        const description = document.getElementById(`${toolType}-desc`);
        if (description) {
            description.classList.remove('visible');
        }
    });

    img.addEventListener('click', () => {
        selectedTool = toolType;
        
        const toolNameSpan = document.getElementById('tool-name');
        if (toolType === 'rock') {
            toolNameSpan.textContent = 'a ROCK';
        } else if (toolType === 'sledgehammer') {
            toolNameSpan.textContent = 'a SLEDGEHAMMER';
        } else if (toolType === 'dynamite') {
            toolNameSpan.textContent = 'DYNAMITE';
        }
        
        document.getElementById('tool-selection').classList.add('hidden');
        document.getElementById('instructions-container').classList.add('visible');
    });
});

let startTime = null;
let timerInterval = null;
const timerElement = document.querySelector('.timer');

function updateTimer() {
    if (!startTime) return;
    
    const elapsed = Date.now() - startTime;
    const seconds = Math.floor(elapsed / 1000);
    const milliseconds = Math.floor((elapsed % 1000) / 10);
    
    const formattedTime = `${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    timerElement.textContent = formattedTime;
}

let currentHealth = 20;
let maxHealth = 20;
let canAttack = true;
let totalDestroyed = 0;

function loadNextImage() {
    if (imageQueue.length === 0) {
        endGame();
        return;
    }
    
    const imageNumber = imageQueue[0];
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = isDarkMode ? 'dark' : 'light';
    
    const currentImage = document.getElementById('current-image');
    currentImage.src = `img/no${imageNumber}_${theme}.webp`;
    currentImage.alt = `NO sign ${imageNumber}`;
    
    currentHealth = maxHealth;
    updateHealthBar();
    updateRemainingCount();
    clearCracks();
}

function updateHealthBar() {
    const healthBar = document.getElementById('health-bar');
    const percentage = (currentHealth / maxHealth) * 100;
    healthBar.style.width = `${percentage}%`;
}

function updateRemainingCount() {
    document.getElementById('images-remaining').textContent = imageQueue.length;
}

function shakeImage() {
    const img = document.getElementById('current-image');
    const container = document.getElementById('image-display');
    
    const shakeMultiplier = selectedTool === 'dynamite' ? 2.5 : 1;
    const randomX = (Math.random() - 0.5) * 10 * shakeMultiplier;
    const randomY = (Math.random() - 0.5) * 10 * shakeMultiplier;
    
    img.style.transform = `translate(${randomX}px, ${randomY}px)`;
    
    const cracks = container.querySelectorAll('svg');
    cracks.forEach(crack => {
        crack.style.transform = `translate(${randomX}px, ${randomY}px)`;
    });
    
    setTimeout(() => {
        img.style.transform = 'translate(0, 0)';
        cracks.forEach(crack => {
            crack.style.transform = 'translate(0, 0)';
        });
    }, 100);
}

function setImageCursor() {
    const img = document.getElementById('current-image');
    if (selectedTool) {
        img.style.cursor = `url('img/${selectedTool}_cursor.ico'), auto`;
    }
}

function randomRange(min, max) {
    return min + (max - min) * Math.random();
}

function clamp(x, min, max) {
    return x < min ? min : (x > max ? max : x);
}

function sign(x) {
    return x < 0 ? -1 : 1;
}

let allFragments = [];
const MAX_FRAGMENTS = 200;

function cleanupOldFragments() {
    if (allFragments.length > MAX_FRAGMENTS) {
        const fragmentsToRemove = allFragments.length - MAX_FRAGMENTS;
        
        for (let i = 0; i < fragmentsToRemove; i++) {
            const fragment = allFragments[i];
            if (fragment && fragment.parentNode) {
                fragment.style.transition = 'opacity 0.5s ease-out';
                fragment.style.opacity = '0';
                
                setTimeout(() => {
                    if (fragment.parentNode) {
                        fragment.parentNode.removeChild(fragment);
                    }
                }, 500);
            }
        }
        
        allFragments.splice(0, fragmentsToRemove);
    }
}

function createSmallFragments(imageElement, clickX, clickY) {
    const rect = imageElement.getBoundingClientRect();
    
    const numFragments = Math.floor(randomRange(2, 5));
    
    for (let i = 0; i < numFragments; i++) {
        const fragment = document.createElement('canvas');
        const ctx = fragment.getContext('2d');
        
        const startX = clickX + randomRange(-30, 30);
        const startY = clickY + randomRange(-30, 30);
        
        const size = randomRange(5, 15);
        const points = [];
        const numPoints = Math.floor(randomRange(3, 5));
        
        for (let j = 0; j < numPoints; j++) {
            const pointAngle = (j / numPoints) * TWO_PI;
            const pointRadius = size * randomRange(0.5, 1);
            points.push({
                x: Math.cos(pointAngle) * pointRadius,
                y: Math.sin(pointAngle) * pointRadius
            });
        }
        
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxY = Math.max(...points.map(p => p.y));
        const width = maxX - minX;
        const height = maxY - minY;
        
        fragment.width = width;
        fragment.height = height;
        fragment.style.width = width + 'px';
        fragment.style.height = height + 'px';
        fragment.style.position = 'fixed';
        fragment.style.pointerEvents = 'none';
        fragment.style.zIndex = '500';
        
        ctx.save();
        ctx.translate(-minX, -minY);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let j = 1; j < points.length; j++) {
            ctx.lineTo(points[j].x, points[j].y);
        }
        ctx.closePath();
        ctx.clip();
        
        const relativeX = startX - rect.left;
        const relativeY = startY - rect.top;
        const imgX = -relativeX - minX;
        const imgY = -relativeY - minY;
        ctx.drawImage(imageElement, imgX, imgY, rect.width, rect.height);
        ctx.restore();
        
        const angle = randomRange(0, TWO_PI);
        const speed = randomRange(50, 150);
        const velocityX = Math.cos(angle) * speed;
        const velocityY = Math.sin(angle) * speed - randomRange(100, 200);
        const rotationSpeed = randomRange(-720, 720);
        
        const gravity = 800;
        const friction = 0.6;
        const groundY = window.innerHeight - height;
        
        let posX = startX;
        let posY = startY;
        let velX = velocityX;
        let velY = velocityY;
        let rotation = randomRange(0, 360);
        let isAnimating = true;
        
        fragment.style.left = posX + 'px';
        fragment.style.top = posY + 'px';
        fragment.style.transform = `rotate(${rotation}deg)`;
        
        const animate = () => {
            if (isAnimating) {
                const deltaTime = 0.016;
                
                velY += gravity * deltaTime;
                
                posX += velX * deltaTime;
                posY += velY * deltaTime;
                rotation += rotationSpeed * deltaTime;
                
                if (posY >= groundY) {
                    posY = groundY;
                    velY = -velY * friction;
                    velX *= friction;
                    
                    if (Math.abs(velY) < 20 && Math.abs(velX) < 20) {
                        isAnimating = false;
                        velY = 0;
                        velX = 0;
                    }
                }
                
                fragment.style.left = posX + 'px';
                fragment.style.top = posY + 'px';
                fragment.style.transform = `rotate(${rotation}deg)`;
                
                if (isAnimating) {
                    requestAnimationFrame(animate);
                }
            }
        };
        
        requestAnimationFrame(animate);
        
        document.body.appendChild(fragment);
        allFragments.push(fragment);
    }
    
    cleanupOldFragments();
}

// Store crack paths for fragmenting the image later
let crackPaths = [];

function createCrack(clickX, clickY, crackType) {
    const container = document.getElementById('image-display');
    const img = document.getElementById('current-image');
    const imgRect = img.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    const relativeX = clickX - imgRect.left;
    const relativeY = clickY - imgRect.top;
    
    const imgWidth = imgRect.width;
    const imgHeight = imgRect.height;
    
    if (relativeX < 0 || relativeX > imgWidth || relativeY < 0 || relativeY > imgHeight) {
        return;
    }
    
    const margin = 0.125;
    const minX = imgWidth * margin;
    const maxX = imgWidth * (1 - margin);
    const minY = imgHeight * margin;
    const maxY = imgHeight * (1 - margin);
    
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const crackColor = isDarkMode ? '#000000' : '#FFFFFF';
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.position = 'absolute';
    svg.style.top = (imgRect.top - containerRect.top) + 'px';
    svg.style.left = (imgRect.left - containerRect.left) + 'px';
    svg.style.width = imgWidth + 'px';
    svg.style.height = imgHeight + 'px';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '10';
    svg.style.transition = 'transform 0.1s ease-out';
    svg.setAttribute('viewBox', `0 0 ${imgWidth} ${imgHeight}`);
    
    let numBranches, strokeWidth, segmentLength, segments;
    
    if (crackType === 'light') {
        numBranches = Math.floor(randomRange(3, 5));
        strokeWidth = randomRange(1.2, 1.5);
        segmentLength = randomRange(25, 45);
        segments = Math.floor(randomRange(8, 12));
    } else {
        numBranches = Math.floor(randomRange(6, 10));
        strokeWidth = randomRange(1.6, 1.9);
        segmentLength = randomRange(35, 65);
        segments = Math.floor(randomRange(12, 18));
    }
    
    for (let i = 0; i < numBranches; i++) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const pathPoints = []; // Store points for this crack path
        
        let pathData = `M ${relativeX} ${relativeY}`;
        pathPoints.push({ x: relativeX, y: relativeY });
        
        const baseAngle = (i / numBranches) * 360 + randomRange(-30, 30);
        let currentX = relativeX;
        let currentY = relativeY;
        let currentAngle = baseAngle;
        
        for (let j = 0; j < segments; j++) {
            const currentSegmentLength = segmentLength * (1 - j / segments * 0.3);
            
            currentAngle += randomRange(-25, 25);
            
            const radians = (currentAngle * Math.PI) / 180;
            let nextX = currentX + Math.cos(radians) * currentSegmentLength;
            let nextY = currentY + Math.sin(radians) * currentSegmentLength;
            
            nextX = Math.max(minX, Math.min(maxX, nextX));
            nextY = Math.max(minY, Math.min(maxY, nextY));
            
            let controlX = (currentX + nextX) / 2 + randomRange(-5, 5);
            let controlY = (currentY + nextY) / 2 + randomRange(-5, 5);
            
            controlX = Math.max(minX, Math.min(maxX, controlX));
            controlY = Math.max(minY, Math.min(maxY, controlY));
            
            pathData += ` Q ${controlX} ${controlY} ${nextX} ${nextY}`;
            pathPoints.push({ x: nextX, y: nextY });
            
            if (nextX === minX || nextX === maxX || nextY === minY || nextY === maxY) {
                break;
            }
            
            currentX = nextX;
            currentY = nextY;
            
            const branchChance = crackType === 'light' ? 0.25 : 0.4;
            if (Math.random() < branchChance && j > 2 && j < segments - 2) {
                const branchAngle = currentAngle + randomRange(-70, 70);
                const branchLength = randomRange(20, 40);
                const branchRad = (branchAngle * Math.PI) / 180;
                let branchX = currentX + Math.cos(branchRad) * branchLength;
                let branchY = currentY + Math.sin(branchRad) * branchLength;
                
                branchX = Math.max(minX, Math.min(maxX, branchX));
                branchY = Math.max(minY, Math.min(maxY, branchY));
                
                pathData += ` M ${currentX} ${currentY} L ${branchX} ${branchY}`;
                pathData += ` M ${currentX} ${currentY}`;
                
                // Store branch as a separate path
                crackPaths.push([
                    { x: currentX, y: currentY },
                    { x: branchX, y: branchY }
                ]);
            }
        }
        
        path.setAttribute('d', pathData);
        path.setAttribute('stroke', crackColor);
        path.setAttribute('stroke-width', strokeWidth);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('opacity', '1');
        
        svg.appendChild(path);
        
        // Store the main crack path
        crackPaths.push(pathPoints);
    }
    
    container.appendChild(svg);
}

function clearCracks() {
    const container = document.getElementById('image-display');
    const cracks = container.querySelectorAll('svg');
    cracks.forEach(crack => crack.remove());
    crackPaths = [];
}

// Function to find regions divided by crack lines
function createFragmentsFromCracks(imageElement, tool) {
    const rect = imageElement.getBoundingClientRect();
    
    if (crackPaths.length === 0) {
        // Fallback to original behavior if no cracks
        createGlassFragmentsFallback(imageElement, rect.left + rect.width / 2, rect.top + rect.height / 2, tool);
        return;
    }
    
    // Create a grid of sample points to determine regions
    const gridSize = 20;
    const regions = [];
    
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const centerX = (x + 0.5) * (rect.width / gridSize);
            const centerY = (y + 0.5) * (rect.height / gridSize);
            
            // Create a fragment for this region
            const fragment = document.createElement('canvas');
            const ctx = fragment.getContext('2d');
            
            // Create an irregular polygon around this point
            const points = [];
            const numPoints = Math.floor(randomRange(4, 7));
            const baseRadius = Math.min(rect.width, rect.height) / gridSize * randomRange(0.8, 1.2);
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * TWO_PI;
                const radius = baseRadius * randomRange(0.6, 1.4);
                points.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            }
            
            // Calculate bounding box
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            
            if (width < 5 || height < 5) continue;
            
            fragment.width = width;
            fragment.height = height;
            fragment.style.width = width + 'px';
            fragment.style.height = height + 'px';
            fragment.style.position = 'fixed';
            fragment.style.pointerEvents = 'none';
            fragment.style.zIndex = '500';
            
            // Draw the fragment
            ctx.save();
            ctx.translate(-minX, -minY);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.clip();
            
            // Draw the image portion
            ctx.drawImage(imageElement, 0, 0, rect.width, rect.height);
            ctx.restore();
            
            // Position and animate
            const startX = rect.left + centerX;
            const startY = rect.top + centerY;
            
            const dx = centerX - rect.width / 2;
            const dy = centerY - rect.height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const isDynamite = tool === 'dynamite';
            const velocityMultiplier = isDynamite ? 3 : 1.5;
            const velocityX = (dx / Math.max(distance, 1)) * randomRange(100, 300) * velocityMultiplier;
            const velocityY = (dy / Math.max(distance, 1)) * randomRange(50, 200) * velocityMultiplier - randomRange(100, 300);
            const rotationSpeed = randomRange(-360, 360);
            
            const gravity = 600;
            const friction = 0.5;
            const groundY = window.innerHeight - height;
            
            let posX = startX - width / 2;
            let posY = startY - height / 2;
            let velX = velocityX;
            let velY = velocityY;
            let rotation = randomRange(0, 360);
            let isAnimating = true;
            
            fragment.style.left = posX + 'px';
            fragment.style.top = posY + 'px';
            fragment.style.transform = `rotate(${rotation}deg)`;
            
            const animate = () => {
                if (isAnimating) {
                    const deltaTime = 0.016;
                    
                    velY += gravity * deltaTime;
                    
                    posX += velX * deltaTime;
                    posY += velY * deltaTime;
                    rotation += rotationSpeed * deltaTime;
                    
                    if (posY >= groundY) {
                        posY = groundY;
                        velY = -velY * friction;
                        velX *= friction;
                        
                        if (Math.abs(velY) < 30 && Math.abs(velX) < 30) {
                            isAnimating = false;
                            velY = 0;
                            velX = 0;
                        }
                    }
                    
                    fragment.style.left = posX + 'px';
                    fragment.style.top = posY + 'px';
                    fragment.style.transform = `rotate(${rotation}deg)`;
                    
                    if (isAnimating) {
                        requestAnimationFrame(animate);
                    }
                }
            };
            
            const delay = randomRange(0, 100);
            setTimeout(() => {
                requestAnimationFrame(animate);
            }, delay);
            
            document.body.appendChild(fragment);
            allFragments.push(fragment);
        }
    }
    
    cleanupOldFragments();
}

function createGlassFragmentsFallback(imageElement, clickX, clickY, tool) {
    const rect = imageElement.getBoundingClientRect();
    const numFragments = 80;
    
    for (let i = 0; i < numFragments; i++) {
        const fragment = document.createElement('canvas');
        const ctx = fragment.getContext('2d');
        
        const startX = rect.left + randomRange(0, rect.width);
        const startY = rect.top + randomRange(0, rect.height);
        
        const size = randomRange(15, 45);
        const points = [];
        const numPoints = Math.floor(randomRange(3, 6));
        
        for (let j = 0; j < numPoints; j++) {
            const pointAngle = (j / numPoints) * TWO_PI;
            const pointRadius = size * randomRange(0.5, 1);
            points.push({
                x: Math.cos(pointAngle) * pointRadius,
                y: Math.sin(pointAngle) * pointRadius
            });
        }
        
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxY = Math.max(...points.map(p => p.y));
        const width = maxX - minX;
        const height = maxY - minY;
        
        fragment.width = width;
        fragment.height = height;
        fragment.style.width = width + 'px';
        fragment.style.height = height + 'px';
        fragment.style.position = 'fixed';
        fragment.style.pointerEvents = 'none';
        fragment.style.zIndex = '500';
        
        ctx.save();
        ctx.translate(-minX, -minY);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let j = 1; j < points.length; j++) {
            ctx.lineTo(points[j].x, points[j].y);
        }
        ctx.closePath();
        ctx.clip();
        
        const relativeX = startX - rect.left;
        const relativeY = startY - rect.top;
        const imgX = -relativeX - minX;
        const imgY = -relativeY - minY;
        ctx.drawImage(imageElement, imgX, imgY, rect.width, rect.height);
        ctx.restore();
        
        const dx = startX - (rect.left + rect.width / 2);
        const dy = startY - (rect.top + rect.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const isDynamite = tool === 'dynamite';
        const velocityMultiplier = isDynamite ? 2.5 : 1;
        const velocityX = (dx / Math.max(distance, 1)) * randomRange(100, 250) * velocityMultiplier;
        const velocityY = randomRange(-300, -100) * velocityMultiplier;
        const rotationSpeed = randomRange(-360, 360);
        
        const gravity = 600;
        const friction = 0.5;
        const groundY = window.innerHeight - height;
        
        let posX = startX;
        let posY = startY;
        let velX = velocityX;
        let velY = velocityY;
        let rotation = randomRange(0, 360);
        let isAnimating = true;
        
        fragment.style.left = posX + 'px';
        fragment.style.top = posY + 'px';
        fragment.style.transform = `rotate(${rotation}deg)`;
        
        const animate = () => {
            if (isAnimating) {
                const deltaTime = 0.016;
                
                velY += gravity * deltaTime;
                
                posX += velX * deltaTime;
                posY += velY * deltaTime;
                rotation += rotationSpeed * deltaTime;
                
                if (posY >= groundY) {
                    posY = groundY;
                    velY = -velY * friction;
                    velX *= friction;
                    
                    if (Math.abs(velY) < 30 && Math.abs(velX) < 30) {
                        isAnimating = false;
                        velY = 0;
                        velX = 0;
                    }
                }
                
                fragment.style.left = posX + 'px';
                fragment.style.top = posY + 'px';
                fragment.style.transform = `rotate(${rotation}deg)`;
                
                if (isAnimating) {
                    requestAnimationFrame(animate);
                }
            }
        };
        
        const delay = randomRange(0, 50);
        setTimeout(() => {
            requestAnimationFrame(animate);
        }, delay);
        
        document.body.appendChild(fragment);
        allFragments.push(fragment);
    }
    
    cleanupOldFragments();
}

let lastClickPosition = { x: 0, y: 0 };
let lightCracksShown = false;
let heavyCracksShown = false;
let isImageBreaking = false;

function attackImage(event) {
    if (!canAttack || imageQueue.length === 0 || isImageBreaking) return;
    
    lastClickPosition.x = event.clientX;
    lastClickPosition.y = event.clientY;
    
    const damage = toolStats[selectedTool].damage;
    currentHealth -= damage;
    
    if (currentHealth < 0) currentHealth = 0;
    
    playToolSound(selectedTool);
    shakeImage();
    
    const img = document.getElementById('current-image');
    createSmallFragments(img, lastClickPosition.x, lastClickPosition.y);
    
    const healthPercent = (currentHealth / maxHealth) * 100;
    
    if (healthPercent <= 70 && !lightCracksShown) {
        createCrack(lastClickPosition.x, lastClickPosition.y, 'light');
        lightCracksShown = true;
    }
    
    if (healthPercent <= 30 && !heavyCracksShown) {
        createCrack(lastClickPosition.x, lastClickPosition.y, 'heavy');
        heavyCracksShown = true;
    }
    
    updateHealthBar();
    
    if (currentHealth <= 0) {
        isImageBreaking = true;
        
        setTimeout(() => {
            clearCracks();
            createFragmentsFromCracks(img, selectedTool);
            
            img.style.transition = 'none';
            img.style.opacity = '0';
            
            imageQueue.shift();
            totalDestroyed++;
            
            if (imageQueue.length > 0) {
                setTimeout(() => {
                    img.style.transition = 'transform 0.1s ease-out, opacity 0.3s ease';
                    img.style.opacity = '1';
                    lightCracksShown = false;
                    heavyCracksShown = false;
                    isImageBreaking = false;
                    loadNextImage();
                }, 800);
            } else {
                setTimeout(() => {
                    endGame();
                }, 800);
            }
        }, 100);
    }
    
    canAttack = false;
    setTimeout(() => {
        canAttack = true;
    }, toolStats[selectedTool].cooldown);
}

function getRank(time, count) {
    const timeInSeconds = time / 1000;
    const avgTimePerImage = timeInSeconds / count;
    
    if (avgTimePerImage < 2) return 'S';
    if (avgTimePerImage < 3) return 'A';
    if (avgTimePerImage < 4) return 'B';
    if (avgTimePerImage < 5) return 'C';
    return 'D';
}

function endGame() {
    clearInterval(timerInterval);
    
    const finalTime = Date.now() - startTime;
    const seconds = Math.floor(finalTime / 1000);
    const milliseconds = Math.floor((finalTime % 1000) / 10);
    const formattedTime = `${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    
    document.getElementById('final-time').textContent = formattedTime;
    document.getElementById('final-count').textContent = totalDestroyed;
    document.getElementById('final-rank').textContent = getRank(finalTime, totalDestroyed);
    
    document.getElementById('game-container').classList.remove('visible');
    document.querySelector('.timer').classList.remove('visible');
    document.querySelector('.bottom-marquee-container').classList.remove('visible');
    document.getElementById('results-container').classList.add('visible');
}

document.getElementById('start-button').addEventListener('click', () => {
    document.querySelector('.timer').classList.add('visible');
    document.querySelector('.bottom-marquee-container').classList.add('visible');
    document.getElementById('instructions-container').classList.remove('visible');
    document.getElementById('game-container').classList.add('visible');
    
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 10);
    updateTimer();
    
    loadNextImage();
    setImageCursor();
});

document.getElementById('current-image').addEventListener('click', attackImage);

document.querySelectorAll('.tool-icon').forEach(icon => {
    icon.addEventListener('click', () => {
        const newTool = icon.dataset.tool;
        selectedTool = newTool;
        
        document.querySelectorAll('.tool-icon').forEach(i => {
            const toolType = i.dataset.tool;
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const mode = isDarkMode ? 'dark' : 'light';
            if (i === icon) {
                i.src = `img/${toolType}_${mode}.webp`;
            } else {
                i.src = `img/${toolType}.webp`;
            }
        });
        setImageCursor();
    });
});

document.getElementById('restart-button').addEventListener('click', () => {
    window.location.href = 'https://gab333t.github.io/fuckno/';
});

document.getElementById('return-button').addEventListener('click', () => {
    window.location.href = 'https://gab333t.github.io/fuckno/';
});

document.getElementById('current-image').addEventListener('contextmenu', (e) => {
    e.preventDefault();
});
</script>
</body>
</html>