<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FUCK NO</title>
    <link rel="stylesheet" href="rageroom.css">
    <link rel="icon" type="image/x-icon" href="img/favicon_light.svg">
</head>
<body>
    <div class="marquee-container">
        <a class="marquee-header" href="https://gab333t.github.io/fuckno/">FUCK NO</a>
        <nav class="marquee-nav">
            <a class="marquee-text" href="https://gab333t.github.io/fuckno/about.html"></a>
        </nav>
    </div>

    <div class="error-container" id="error-container">
        <h2 class="body-text error-text">ERROR:<br>Inventory not selected.</h2>
        <button class="start-button" id="return-button">RETURN TO INVENTORY</button>
    </div>

    <div class="tool-selection-container" id="tool-selection">
        <h2 class="body-text">SELECT YOUR TOOL:</h2>
        <div class="tool-container">
            <img src="img/rock.webp" alt="Rock icon." data-tool="rock">
            <img src="img/sledgehammer.webp" alt="Sledgehammer icon." data-tool="sledgehammer">
            <img src="img/dynamite.webp" alt="Dynamite icon." data-tool="dynamite">
        </div>
        
        <div class="tool-descriptions">
            <h2 class="body-text tool-description" id="rock-desc">ROCK<br>Deals 3 damage with a 0.1 second cooldown.</h2>
            <h2 class="body-text tool-description" id="sledgehammer-desc">SLEDGEHAMMER<br>Deals 5 damage with a 0.3 second cooldown.</h2>
            <h2 class="body-text tool-description" id="dynamite-desc">DYNAMITE<br>Deals 8 damage with a 0.5 second cooldown.</h2>
        </div>
    </div>

    <div class="instructions-container" id="instructions-container">
        <h2 class="body-text instructions-text" id="instructions">You're about to destroy the images you've selected as they cycle through a queue.
            You can change the tool during the experience to better accomodate your needs.
            At the end, you'll be ranked based on how long you take and the number of NO's you brought into the RAGE ROOM today.<br><br>
            You'll be starting off with <span id="tool-name"></span>. Don't hold back.
        </h2>
        <button class="start-button" id="start-button">RAGE</button>
    </div>

    <div class="game-container" id="game-container">
        <div class="image-display" id="image-display">
            <img id="current-image" src="" alt="Current NO sign">
            <div class="health-bar-container">
                <div class="health-bar" id="health-bar"></div>
            </div>
        </div>
        
        <div class="game-info">
            <h2 class="body-text info-text">
                <span id="current-image-number">01</span><em>/</em>76
            </h2>
        </div>

        <div class="tool-switcher">
            <h2 class="body-text switch-text">Switch tool:</h2>
            <div class="tool-icons">
                <img src="img/rock.webp" alt="Rock" data-tool="rock" class="tool-icon">
                <img src="img/sledgehammer.webp" alt="Sledgehammer" data-tool="sledgehammer" class="tool-icon">
                <img src="img/dynamite.webp" alt="Dynamite" data-tool="dynamite" class="tool-icon">
            </div>
        </div>
    </div>

    <div class="box-queue-container" id="box-queue-container">
        <div class="box-queue" id="box-queue"></div>
    </div>

    <div class="results-container" id="results-container">
        <h2 class="body-text results-title">RAGE ROOM COMPLETE</h2>
        <div class="results-stats">
            <h2 class="body-text stat-text">Time: <span id="final-time">00:00</span></h2>
            <h2 class="body-text stat-text"><span id="final-count">0</span></h2>
            <h2 class="body-text stat-text">Rank: <span id="final-rank">-</span></h2>
        </div>
        <button class="start-button" id="restart-button">RESTART</button>
    </div>

    <div class="bottom-marquee-container">
        <div class="bottom-marquee">
            <span class="marquee-content">RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM</span>
            <span class="marquee-content">RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM RAGE ROOM</span>
        </div>
    </div>

    <h2 class="timer">00:00</h2>
    <h2 class="current-label"></h2>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script>
const TWO_PI = Math.PI * 2;

const labels = [
    '01. PARKING24HR',
    '02. STANDINGFORCONSTRUCTION',
    '03. BLOCKDRIVEWAY',
    '04. SMOKING',
    '05. ELEVATOR_ICOFIRE',
    '06. DANGERSMOKING',
    '07. DANGERENTER',
    '08. STANDING+PARKING',
    '09. ENTER',
    '10. EATDRINKSMOKE',
    '11. ENTERCROSSTRACK',
    '12. DUMPING',
    '13. FLYERSMENUSADVERTISEMENTS',
    '14. UNSOLICITEDADVERTISEMENTS',
    '15. DUMPINGFINE500',
    '16. SOLICITINGOREXCEPTIONS',
    '17. TRESPASSORPROSECUTE',
    '18. PARKORTOWED',
    '19. STEALMYRECYCLING',
    '20. BLOCKDRIVEWAY',
    '21. TRESPASS',
    '22. TRESPASSONPROPERTY',
    '23. THRUTRAFFIC4HOSPITAL',
    '24. SMOKE25FT',
    '25. BLOCKSTAIRB',
    '26. BLOCKFIREEXIT',
    '27. SMOKING',
    '28. DUMPANDGETPROSECUTED',
    '29. SMOKEVAPEECIG',
    '30. STANDUNDERLIFTS',
    '31. TRESPASS',
    '32. PARKINGFORCONSTRUCTION',
    '33. SOLICITLOITERTRESPASS',
    '34. BLOCKLOADINGDOCK',
    '35. PARKSTANDONPRIVATEST',
    '36. PARKACTIVECROSSING',
    '37. OUTSIDEFOODBEV',
    '38. OVERFIIIIILL',
    '39. PPLONLYOPERATOR',
    '40. EXITXXXXXX',
    '41. CHILDRENONCART',
    '42. TOUCHTHANKS',
    '43. ENTERROOMRUN',
    '44. ENTER',
    '45. COMMERCIALTRAFFIC',
    '46. RESTROOMS4CUSTOMERSONLY',
    '47. LOCKBIKESORGETCUT',
    '48. CHAINBIKE2FENCE',
    '49. TOBACCOVAPE4UNDER21',
    '50. FLYERSADSMENUSPLS',
    '51. SMOKINGDURINGFUELING',
    '52. DUMPINGBYMTA',
    '53. HOUSEHOLDORBUSINESSTRASH',
    '54. IDLINGENGINE',
    '55. PARKINGBYFDNY',
    '56. ENTRYORMAYBEYES',
    '57. HOODIESSKIMASKSBANDANAS',
    '58. DOGORBIKEINSTORE',
    '59. TRESPASSING',
    '60. BLOCKINGPLSANDTHANKS',
    '61. LITTER4CHURCH',
    '62. BALLPLAYING',
    '63. OURLAUNDRYINOURMACHINES',
    '64. TRESPASSINGORPROSECUTED',
    '65. TRESPASSINGONOURPROPERTY',
    '66. STUPIDPPL',
    '67. MOPEDSANDATVS',
    '68. POSTINGBILLS',
    '69. CLIMBING',
    '70. RIDINGINPORTAUTHORITY',
    '71. ENTERBUTDELIVERIESROK',
    '72. SOLICITLOITERORTRESPASS',
    '73. BIKINGINFLATIRON',
    '74. SHOESINDRYERS',
    '75. BUYORSELLEBT',
    '76. SMOKINGBYPUFFIN',
];

function setFavicon() {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const faviconPath = isDarkMode ? 'img/favicon_dark.svg' : 'img/favicon_light.svg';

    let favicon = document.querySelector("link[rel='icon']");
    if (!favicon) {
        favicon = document.createElement('link');
        favicon.rel = 'icon';
        document.head.appendChild(favicon);
    }
    favicon.href = faviconPath;
}

function updateAboutText() {
    const aboutLink = document.querySelector('.marquee-text');
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (window.innerWidth <= 550) {
        const imagePath = isDarkMode ? 'img/about_dark.svg' : 'img/about_light.svg';
        aboutLink.innerHTML = `<img src="${imagePath}" alt="About" class="about-icon" draggable="false">`;
    } else {
        aboutLink.textContent = 'ABOUT';
    }
}

setFavicon();
updateAboutText();

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
    setFavicon();
    updateAboutText();
    updateBoxQueueTheme();
});

window.addEventListener('resize', () => {
    updateAboutText();
    updateBoxQueuePosition();
});

let titleIndex = 0;
const titles = ['FUCK NO', 'RAGE ROOM'];
setInterval(() => {
    titleIndex = (titleIndex + 1) % titles.length;
    document.title = titles[titleIndex];
}, 3000);

function getSelectedImages() {
    const urlParams = new URLSearchParams(window.location.search);
    const selected = urlParams.get('selected');
    
    if (selected) {
        return selected.split(',').map(num => parseInt(num));
    }
    
    return null;
}

const selectedImages = getSelectedImages();

if (selectedImages === null) {
    document.getElementById('error-container').classList.add('visible');
    document.getElementById('tool-selection').style.display = 'none';
} else {
    let currentImageIndex = 0;
    let imageQueue = [...selectedImages];
}

const toolImages = document.querySelectorAll('.tool-container img');
let selectedTool = null;
let currentImageIndex = 0;
let imageQueue = selectedImages ? [...selectedImages] : [];
const toolStats = {
    rock: { damage: 3, cooldown: 100 },
    sledgehammer: { damage: 5, cooldown: 300 },
    dynamite: { damage: 8, cooldown: 500 }
};

function createAudioPool(tool, filename) {
    return [
        `audio/${filename}1.mp3`,
        `audio/${filename}2.mp3`,
        `audio/${filename}3.mp3`
    ];
}

const audioFiles = {
    rock: createAudioPool('rock', 'rock'),
    sledgehammer: createAudioPool('sledgehammer', 'glass'),
    dynamite: createAudioPool('dynamite', 'explode')
};

function playToolSound(tool) {
    const sounds = audioFiles[tool];
    if (sounds) {
        const randomIndex = Math.floor(Math.random() * 3);
        const audioPath = sounds[randomIndex];
        
        const audio = new Audio(audioPath);
        audio.volume = 0.7;
        audio.play().catch(err => {
            console.log(`Audio play failed for ${tool}:`, err);
            console.log('Attempted path:', audioPath);
        });
    }
}

toolImages.forEach(img => {
    const originalSrc = img.src;
    const altText = img.alt;
    const toolType = img.dataset.tool;
    
    img.addEventListener('mouseenter', () => {
        const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const mode = isDarkMode ? 'dark' : 'light';
        
        if (altText.includes('Sledgehammer')) {
            img.src = `img/sledgehammer_${mode}.webp`;
        } else if (altText.includes('Dynamite')) {
            img.src = `img/dynamite_${mode}.webp`;
        } else if (altText.includes('Rock')) {
            img.src = `img/rock_${mode}.webp`;
        }
        
        const description = document.getElementById(`${toolType}-desc`);
        if (description) {
            description.classList.add('visible');
        }
    });
    
    img.addEventListener('mouseleave', () => {
        img.src = originalSrc;
        
        const description = document.getElementById(`${toolType}-desc`);
        if (description) {
            description.classList.remove('visible');
        }
    });

    img.addEventListener('click', () => {
        selectedTool = toolType;
        
        const toolNameSpan = document.getElementById('tool-name');
        if (toolType === 'rock') {
            toolNameSpan.textContent = 'a ROCK';
        } else if (toolType === 'sledgehammer') {
            toolNameSpan.textContent = 'a SLEDGEHAMMER';
        } else if (toolType === 'dynamite') {
            toolNameSpan.textContent = 'DYNAMITE';
        }
        
        document.getElementById('tool-selection').classList.add('hidden');
        document.getElementById('instructions-container').classList.add('visible');
    });
});

let startTime = null;
let timerInterval = null;
const timerElement = document.querySelector('.timer');

function updateTimer() {
    if (!startTime) return;
    
    const elapsed = Date.now() - startTime;
    const seconds = Math.floor(elapsed / 1000);
    const milliseconds = Math.floor((elapsed % 1000) / 10);
    
    const formattedTime = `${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    timerElement.textContent = formattedTime;
}

let currentHealth = 20;
let maxHealth = 20;
let canAttack = true;
let totalDestroyed = 0;

function initializeBoxQueue() {
    const queueContainer = document.getElementById('box-queue');
    queueContainer.innerHTML = '';
    
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = isDarkMode ? 'dark' : 'light';
    
    imageQueue.forEach((imageNumber, index) => {
        if (index === 0) return;
        
        const box = document.createElement('div');
        box.className = 'queue-box';
        box.dataset.index = index;
        box.dataset.imageNumber = imageNumber;
        
        const img = document.createElement('img');
        img.src = `img/no${imageNumber}_${theme}.webp`;
        img.alt = `Queue preview ${imageNumber}`;
        
        box.appendChild(img);
        queueContainer.appendChild(box);
    });
}

function updateBoxQueueTheme() {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = isDarkMode ? 'dark' : 'light';
    
    const boxes = document.querySelectorAll('.queue-box');
    boxes.forEach(box => {
        const imageNumber = box.dataset.imageNumber;
        const img = box.querySelector('img');
        if (imageNumber) {
            img.src = `img/no${imageNumber}_${theme}.webp`;
        }
    });
}

function animateBoxTransition() {
    const queueContainer = document.getElementById('box-queue');
    const boxes = queueContainer.querySelectorAll('.queue-box');
    
    if (boxes.length === 0) return;
    
    const firstBox = boxes[0];
    const currentImage = document.getElementById('current-image');
    const imageRect = currentImage.getBoundingClientRect();
    const boxRect = firstBox.getBoundingClientRect();
    
    const animatingBox = firstBox.cloneNode(true);
    animatingBox.classList.add('animating');
    document.body.appendChild(animatingBox);
    
    animatingBox.style.left = boxRect.left + 'px';
    animatingBox.style.top = boxRect.top + 'px';
    animatingBox.style.width = boxRect.width + 'px';
    animatingBox.style.height = boxRect.height + 'px';
    
    firstBox.style.width = '0px';
    firstBox.style.marginRight = '-30px';
    firstBox.style.opacity = '0';
    
    setTimeout(() => {
        firstBox.remove();
    }, 800);
    
    requestAnimationFrame(() => {
        animatingBox.style.transition = 'all 0.8s ease';
        animatingBox.style.left = imageRect.left + 'px';
        animatingBox.style.top = imageRect.top + 'px';
        animatingBox.style.width = imageRect.width + 'px';
        animatingBox.style.height = imageRect.height + 'px';
        
        const img = animatingBox.querySelector('img');
        if (img) {
            img.style.filter = 'none';
        }
        
        setTimeout(() => {
            animatingBox.remove();
        }, 800);
    });
}

function loadNextImage() {
    if (imageQueue.length === 0) {
        endGame();
        return;
    }
    
    const imageNumber = imageQueue[0];
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = isDarkMode ? 'dark' : 'light';
    
    const currentImage = document.getElementById('current-image');
    
    currentImage.style.filter = 'grayscale(100%) contrast(1000%) brightness(1000%)';
    
    currentImage.src = `img/no${imageNumber}_${theme}.webp`;
    currentImage.alt = `NO sign ${imageNumber}`;
    
    currentImage.onload = () => {
        setTimeout(() => {
            currentImage.style.filter = 'none';
        }, 100);
    };
    
    const labelElement = document.querySelector('.current-label');
    const fullLabel = labels[imageNumber - 1];
    const labelText = fullLabel.split('. ')[1];
    labelElement.textContent = labelText;
    
    currentHealth = maxHealth;
    updateHealthBar();
    updateImageNumber();
    clearCracks();
    
    updateBoxQueuePosition();
}

function updateBoxQueuePosition() {
    const imageDisplay = document.getElementById('image-display');
    const queueContainer = document.getElementById('box-queue-container');
    
    if (!imageDisplay || !queueContainer) return;
    
    requestAnimationFrame(() => {
        const imageRect = imageDisplay.getBoundingClientRect();
        const imageCenterY = imageRect.top + (imageRect.height / 2);
        
        queueContainer.style.top = imageCenterY + 'px';
        queueContainer.style.transform = 'translateY(-50%)';
    });
}

function updateHealthBar() {
    const healthBar = document.getElementById('health-bar');
    const percentage = (currentHealth / maxHealth) * 100;
    healthBar.style.width = `${percentage}%`;
}

function updateImageNumber() {
    if (imageQueue.length === 0) return;
    
    const imageNumber = imageQueue[0];
    const formattedNumber = String(imageNumber).padStart(2, '0');
    document.getElementById('current-image-number').textContent = formattedNumber;
}

function shakeImage() {
    const img = document.getElementById('current-image');
    const container = document.getElementById('image-display');
    
    const shakeMultiplier = selectedTool === 'dynamite' ? 2.5 : 1;
    const randomX = (Math.random() - 0.5) * 10 * shakeMultiplier;
    const randomY = (Math.random() - 0.5) * 10 * shakeMultiplier;
    
    img.style.transform = `translate(${randomX}px, ${randomY}px)`;
    
    const cracks = container.querySelectorAll('svg');
    cracks.forEach(crack => {
        crack.style.transform = `translate(${randomX}px, ${randomY}px)`;
    });
    
    setTimeout(() => {
        img.style.transform = 'translate(0, 0)';
        cracks.forEach(crack => {
            crack.style.transform = 'translate(0, 0)';
        });
        updateBoxQueuePosition();
    }, 100);
}

function setImageCursor() {
    const img = document.getElementById('current-image');
    if (selectedTool) {
        img.style.cursor = `url('img/${selectedTool}_cursor.ico'), auto`;
    }
}

function randomRange(min, max) {
    return min + (max - min) * Math.random();
}

function clamp(x, min, max) {
    return x < min ? min : (x > max ? max : x);
}

function sign(x) {
    return x < 0 ? -1 : 1;
}

let allFragments = [];
const MAX_FRAGMENTS = 200;

let fragmentAnimations = new Map();

function cleanupOldFragments() {
    if (allFragments.length > MAX_FRAGMENTS) {
        const fragmentsToRemove = allFragments.length - MAX_FRAGMENTS;
        
        for (let i = 0; i < fragmentsToRemove; i++) {
            const fragment = allFragments[i];
            if (fragment && fragment.parentNode) {
                fragment.style.transition = 'opacity 0.5s ease-out';
                fragment.style.opacity = '0';
                
                fragmentAnimations.delete(fragment);
                
                setTimeout(() => {
                    if (fragment.parentNode) {
                        fragment.parentNode.removeChild(fragment);
                    }
                }, 500);
            }
        }
        
        allFragments.splice(0, fragmentsToRemove);
    }
}

window.addEventListener('resize', () => {
    fragmentAnimations.forEach((data, fragment) => {
        const newGroundY = window.innerHeight - fragment.height;
        const oldGroundY = data.groundY;
        data.groundY = newGroundY;
        
        if (!data.isAnimating && data.posY >= oldGroundY - 5) {
            data.posY = newGroundY;
            fragment.style.top = data.posY + 'px';
        }
        else if (data.posY > newGroundY) {
            data.posY = newGroundY;
            fragment.style.top = data.posY + 'px';
        }
    });
    
    updateBoxQueuePosition();
});

function createSmallFragments(imageElement, clickX, clickY) {
    const rect = imageElement.getBoundingClientRect();
    
    const numFragments = Math.floor(randomRange(2, 5));
    
    for (let i = 0; i < numFragments; i++) {
        const fragment = document.createElement('canvas');
        const ctx = fragment.getContext('2d');
        
        const startX = clickX + randomRange(-30, 30);
        const startY = clickY + randomRange(-30, 30);
        
        const size = randomRange(5, 15);
        const points = [];
        const numPoints = Math.floor(randomRange(3, 5));
        
        for (let j = 0; j < numPoints; j++) {
            const pointAngle = (j / numPoints) * TWO_PI;
            const pointRadius = size * randomRange(0.5, 1);
            points.push({
                x: Math.cos(pointAngle) * pointRadius,
                y: Math.sin(pointAngle) * pointRadius
            });
        }
        
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxY = Math.max(...points.map(p => p.y));
        const width = maxX - minX;
        const height = maxY - minY;
        
        fragment.width = width;
        fragment.height = height;
        fragment.style.width = width + 'px';
        fragment.style.height = height + 'px';
        fragment.style.position = 'fixed';
        fragment.style.pointerEvents = 'none';
        fragment.style.zIndex = '500';
        
        ctx.save();
        ctx.translate(-minX, -minY);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let j = 1; j < points.length; j++) {
            ctx.lineTo(points[j].x, points[j].y);
        }
        ctx.closePath();
        ctx.clip();
        
        const relativeX = startX - rect.left;
        const relativeY = startY - rect.top;
        const imgX = -relativeX - minX;
        const imgY = -relativeY - minY;
        ctx.drawImage(imageElement, imgX, imgY, rect.width, rect.height);
        ctx.restore();
        
        const angle = randomRange(0, TWO_PI);
        const speed = randomRange(50, 150);
        const velocityX = Math.cos(angle) * speed;
        const velocityY = Math.sin(angle) * speed - randomRange(100, 200);
        const rotationSpeed = randomRange(-720, 720);
        
        const gravity = 800;
        const friction = 0.6;
        
        let posX = startX;
        let posY = startY;
        let velX = velocityX;
        let velY = velocityY;
        let rotation = randomRange(0, 360);
        let isAnimating = true;
        
        const animationData = {
            posX, posY, velX, velY, rotation,
            gravity, friction, rotationSpeed,
            isAnimating,
            groundY: window.innerHeight - height
        };
        
        fragment.style.left = posX + 'px';
        fragment.style.top = posY + 'px';
        fragment.style.transform = `rotate(${rotation}deg)`;
        
        const animate = () => {
            if (animationData.isAnimating) {
                const deltaTime = 0.016;
                
                animationData.velY += animationData.gravity * deltaTime;
                
                animationData.posX += animationData.velX * deltaTime;
                animationData.posY += animationData.velY * deltaTime;
                animationData.rotation += animationData.rotationSpeed * deltaTime;
                
                if (animationData.posY >= animationData.groundY) {
                    animationData.posY = animationData.groundY;
                    animationData.velY = -animationData.velY * animationData.friction;
                    animationData.velX *= animationData.friction;
                    
                    if (Math.abs(animationData.velY) < 20 && Math.abs(animationData.velX) < 20) {
                        animationData.isAnimating = false;
                        animationData.velY = 0;
                        animationData.velX = 0;
                    }
                }
                
                fragment.style.left = animationData.posX + 'px';
                fragment.style.top = animationData.posY + 'px';
                fragment.style.transform = `rotate(${animationData.rotation}deg)`;
                
                if (animationData.isAnimating) {
                    requestAnimationFrame(animate);
                }
            }
        };
        
        requestAnimationFrame(animate);
        
        document.body.appendChild(fragment);
        allFragments.push(fragment);
        fragmentAnimations.set(fragment, animationData);
    }
    
    cleanupOldFragments();
}

let crackPaths = [];

function createCrack(clickX, clickY, crackType) {
    const container = document.getElementById('image-display');
    const img = document.getElementById('current-image');
    const imgRect = img.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    const relativeX = clickX - imgRect.left;
    const relativeY = clickY - imgRect.top;
    
    const imgWidth = imgRect.width;
    const imgHeight = imgRect.height;
    
    if (relativeX < 0 || relativeX > imgWidth || relativeY < 0 || relativeY > imgHeight) {
        return;
    }
    
    const margin = 0.125;
    const minX = imgWidth * margin;
    const maxX = imgWidth * (1 - margin);
    const minY = imgHeight * margin;
    const maxY = imgHeight * (1 - margin);
    
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const crackColor = isDarkMode ? '#000000' : '#FFFFFF';
    
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.position = 'absolute';
    svg.style.top = (imgRect.top - containerRect.top) + 'px';
    svg.style.left = (imgRect.left - containerRect.left) + 'px';
    svg.style.width = imgWidth + 'px';
    svg.style.height = imgHeight + 'px';
    svg.style.pointerEvents = 'none';
    svg.style.zIndex = '10';
    svg.style.transition = 'transform 0.1s ease-out';
    svg.setAttribute('viewBox', `0 0 ${imgWidth} ${imgHeight}`);
    
    let numBranches, strokeWidth, segmentLength, segments;
    
    if (crackType === 'light') {
        numBranches = Math.floor(randomRange(3, 5));
        strokeWidth = randomRange(1.2, 1.5);
        segmentLength = randomRange(25, 45);
        segments = Math.floor(randomRange(8, 12));
    } else {
        numBranches = Math.floor(randomRange(6, 10));
        strokeWidth = randomRange(1.6, 1.9);
        segmentLength = randomRange(35, 65);
        segments = Math.floor(randomRange(12, 18));
    }
    
    for (let i = 0; i < numBranches; i++) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const pathPoints = [];
        
        let pathData = `M ${relativeX} ${relativeY}`;
        pathPoints.push({ x: relativeX, y: relativeY });
        
        const baseAngle = (i / numBranches) * 360 + randomRange(-30, 30);
        let currentX = relativeX;
        let currentY = relativeY;
        let currentAngle = baseAngle;
        
        for (let j = 0; j < segments; j++) {
            const currentSegmentLength = segmentLength * (1 - j / segments * 0.3);
            
            currentAngle += randomRange(-25, 25);
            
            const radians = (currentAngle * Math.PI) / 180;
            let nextX = currentX + Math.cos(radians) * currentSegmentLength;
            let nextY = currentY + Math.sin(radians) * currentSegmentLength;
            
            nextX = Math.max(minX, Math.min(maxX, nextX));
            nextY = Math.max(minY, Math.min(maxY, nextY));
            
            let controlX = (currentX + nextX) / 2 + randomRange(-5, 5);
            let controlY = (currentY + nextY) / 2 + randomRange(-5, 5);
            
            controlX = Math.max(minX, Math.min(maxX, controlX));
            controlY = Math.max(minY, Math.min(maxY, controlY));
            
            pathData += ` Q ${controlX} ${controlY} ${nextX} ${nextY}`;
            pathPoints.push({ x: nextX, y: nextY });
            
            if (nextX === minX || nextX === maxX || nextY === minY || nextY === maxY) {
                break;
            }
            
            currentX = nextX;
            currentY = nextY;
            
            const branchChance = crackType === 'light' ? 0.25 : 0.4;
            if (Math.random() < branchChance && j > 2 && j < segments - 2) {
                const branchAngle = currentAngle + randomRange(-70, 70);
                const branchLength = randomRange(20, 40);
                const branchRad = (branchAngle * Math.PI) / 180;
                let branchX = currentX + Math.cos(branchRad) * branchLength;
                let branchY = currentY + Math.sin(branchRad) * branchLength;
                
                branchX = Math.max(minX, Math.min(maxX, branchX));
                branchY = Math.max(minY, Math.min(maxY, branchY));
                
                pathData += ` M ${currentX} ${currentY} L ${branchX} ${branchY}`;
                pathData += ` M ${currentX} ${currentY}`;
                
                crackPaths.push([
                    { x: currentX, y: currentY },
                    { x: branchX, y: branchY }
                ]);
            }
        }
        
        path.setAttribute('d', pathData);
        path.setAttribute('stroke', crackColor);
        path.setAttribute('stroke-width', strokeWidth);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('opacity', '1');
        
        svg.appendChild(path);
        
        crackPaths.push(pathPoints);
    }
    
    container.appendChild(svg);
}

function clearCracks() {
    const container = document.getElementById('image-display');
    const cracks = container.querySelectorAll('svg');
    cracks.forEach(crack => crack.remove());
    crackPaths = [];
}

function createFragmentsFromCracks(imageElement, tool) {
    const rect = imageElement.getBoundingClientRect();
    
    if (crackPaths.length === 0) {
        createGlassFragmentsFallback(imageElement, rect.left + rect.width / 2, rect.top + rect.height / 2, tool);
        return;
    }
    
    const gridSize = 4;
    const regions = [];
    
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const centerX = (x + 0.5) * (rect.width / gridSize);
            const centerY = (y + 0.5) * (rect.height / gridSize);
            
            const fragment = document.createElement('canvas');
            const ctx = fragment.getContext('2d');
            
            const points = [];
            const numPoints = Math.floor(randomRange(4, 7));
            const baseRadius = Math.min(rect.width, rect.height) / gridSize * randomRange(1.2, 1.6);
            
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * TWO_PI;
                const radius = baseRadius * randomRange(1.8, 2.4);
                points.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            }
            
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            
            if (width < 5 || height < 5) continue;
            
            fragment.width = width;
            fragment.height = height;
            fragment.style.width = width + 'px';
            fragment.style.height = height + 'px';
            fragment.style.position = 'fixed';
            fragment.style.pointerEvents = 'none';
            fragment.style.zIndex = '500';
            
            ctx.save();
            ctx.translate(-minX, -minY);
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.clip();
            
            ctx.drawImage(imageElement, 0, 0, rect.width, rect.height);
            ctx.restore();
            
            const startX = rect.left + centerX;
            const startY = rect.top + centerY;
            
            const dx = centerX - rect.width / 2;
            const dy = centerY - rect.height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const isDynamite = tool === 'dynamite';
            const velocityMultiplier = isDynamite ? 3 : 1.5;
            const velocityX = (dx / Math.max(distance, 1)) * randomRange(100, 300) * velocityMultiplier;
            const velocityY = (dy / Math.max(distance, 1)) * randomRange(50, 200) * velocityMultiplier - randomRange(100, 300);
            const rotationSpeed = randomRange(-360, 360);
            
            const gravity = 600;
            const friction = 0.5;
            
            let posX = startX - width / 2;
            let posY = startY - height / 2;
            let velX = velocityX;
            let velY = velocityY;
            let rotation = randomRange(0, 360);
            let isAnimating = true;
            
            const animationData = {
                posX, posY, velX, velY, rotation,
                gravity, friction, rotationSpeed,
                isAnimating,
                groundY: window.innerHeight - height
            };
            
            fragment.style.left = posX + 'px';
            fragment.style.top = posY + 'px';
            fragment.style.transform = `rotate(${rotation}deg)`;
            
            const animate = () => {
                if (animationData.isAnimating) {
                    const deltaTime = 0.016;
                    
                    animationData.velY += animationData.gravity * deltaTime;
                    
                    animationData.posX += animationData.velX * deltaTime;
                    animationData.posY += animationData.velY * deltaTime;
                    animationData.rotation += animationData.rotationSpeed * deltaTime;
                    
                    if (animationData.posY >= animationData.groundY) {
                        animationData.posY = animationData.groundY;
                        animationData.velY = -animationData.velY * animationData.friction;
                        animationData.velX *= animationData.friction;
                        
                        if (Math.abs(animationData.velY) < 30 && Math.abs(animationData.velX) < 30) {
                            animationData.isAnimating = false;
                            animationData.velY = 0;
                            animationData.velX = 0;
                        }
                    }
                    
                    fragment.style.left = animationData.posX + 'px';
                    fragment.style.top = animationData.posY + 'px';
                    fragment.style.transform = `rotate(${animationData.rotation}deg)`;
                    
                    if (animationData.isAnimating) {
                        requestAnimationFrame(animate);
                    }
                }
            };
            
            const delay = randomRange(0, 100);
            setTimeout(() => {
                requestAnimationFrame(animate);
            }, delay);
            
            document.body.appendChild(fragment);
            allFragments.push(fragment);
            fragmentAnimations.set(fragment, animationData);
        }
    }
    
    cleanupOldFragments();
}

function createGlassFragmentsFallback(imageElement, clickX, clickY, tool) {
    const rect = imageElement.getBoundingClientRect();
    const numFragments = 30;
    
    for (let i = 0; i < numFragments; i++) {
        const fragment = document.createElement('canvas');
        const ctx = fragment.getContext('2d');
        
        const startX = rect.left + randomRange(0, rect.width);
        const startY = rect.top + randomRange(0, rect.height);
        
        const size = randomRange(25, 75);
        const points = [];
        const numPoints = Math.floor(randomRange(3, 6));
        
        for (let j = 0; j < numPoints; j++) {
            const pointAngle = (j / numPoints) * TWO_PI;
            const pointRadius = size * randomRange(0.5, 1);
            points.push({
                x: Math.cos(pointAngle) * pointRadius,
                y: Math.sin(pointAngle) * pointRadius
            });
        }
        
        const minX = Math.min(...points.map(p => p.x));
        const maxX = Math.max(...points.map(p => p.x));
        const minY = Math.min(...points.map(p => p.y));
        const maxY = Math.max(...points.map(p => p.y));
        const width = maxX - minX;
        const height = maxY - minY;
        
        fragment.width = width;
        fragment.height = height;
        fragment.style.width = width + 'px';
        fragment.style.height = height + 'px';
        fragment.style.position = 'fixed';
        fragment.style.pointerEvents = 'none';
        fragment.style.zIndex = '500';
        
        ctx.save();
        ctx.translate(-minX, -minY);
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let j = 1; j < points.length; j++) {
            ctx.lineTo(points[j].x, points[j].y);
        }
        ctx.closePath();
        ctx.clip();
        
        const relativeX = startX - rect.left;
        const relativeY = startY - rect.top;
        const imgX = -relativeX - minX;
        const imgY = -relativeY - minY;
        ctx.drawImage(imageElement, imgX, imgY, rect.width, rect.height);
        ctx.restore();
        
        const dx = startX - (rect.left + rect.width / 2);
        const dy = startY - (rect.top + rect.height / 2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const isDynamite = tool === 'dynamite';
        const velocityMultiplier = isDynamite ? 2.5 : 1;
        const velocityX = (dx / Math.max(distance, 1)) * randomRange(100, 250) * velocityMultiplier;
        const velocityY = randomRange(-300, -100) * velocityMultiplier;
        const rotationSpeed = randomRange(-360, 360);
        
        const gravity = 600;
        const friction = 0.5;
        
        let posX = startX;
        let posY = startY;
        let velX = velocityX;
        let velY = velocityY;
        let rotation = randomRange(0, 360);
        let isAnimating = true;
        
        const animationData = {
            posX, posY, velX, velY, rotation,
            gravity, friction, rotationSpeed,
            isAnimating,
            groundY: window.innerHeight - height
        };
        
        fragment.style.left = posX + 'px';
        fragment.style.top = posY + 'px';
        fragment.style.transform = `rotate(${rotation}deg)`;
        
        const animate = () => {
            if (animationData.isAnimating) {
                const deltaTime = 0.016;
                
                animationData.velY += animationData.gravity * deltaTime;
                
                animationData.posX += animationData.velX * deltaTime;
                animationData.posY += animationData.velY * deltaTime;
                animationData.rotation += animationData.rotationSpeed * deltaTime;
                
                if (animationData.posY >= animationData.groundY) {
                    animationData.posY = animationData.groundY;
                    animationData.velY = -animationData.velY * animationData.friction;
                    animationData.velX *= animationData.friction;
                    
                    if (Math.abs(animationData.velY) < 30 && Math.abs(animationData.velX) < 30) {
                        animationData.isAnimating = false;
                        animationData.velY = 0;
                        animationData.velX = 0;
                    }
                }
                
                fragment.style.left = animationData.posX + 'px';
                fragment.style.top = animationData.posY + 'px';
                fragment.style.transform = `rotate(${animationData.rotation}deg)`;
                
                if (animationData.isAnimating) {
                    requestAnimationFrame(animate);
                }
            }
        };
        
        const delay = randomRange(0, 50);
        setTimeout(() => {
            requestAnimationFrame(animate);
        }, delay);
        
        document.body.appendChild(fragment);
        allFragments.push(fragment);
        fragmentAnimations.set(fragment, animationData);
    }
    
    cleanupOldFragments();
}

let lastClickPosition = { x: 0, y: 0 };
let lightCracksShown = false;
let heavyCracksShown = false;
let isImageBreaking = false;

function attackImage(event) {
    if (!canAttack || imageQueue.length === 0 || isImageBreaking) return;
    
    lastClickPosition.x = event.clientX;
    lastClickPosition.y = event.clientY;
    
    const damage = toolStats[selectedTool].damage;
    currentHealth -= damage;
    
    if (currentHealth < 0) currentHealth = 0;
    
    playToolSound(selectedTool);
    shakeImage();
    
    const img = document.getElementById('current-image');
    createSmallFragments(img, lastClickPosition.x, lastClickPosition.y);
    
    const healthPercent = (currentHealth / maxHealth) * 100;
    
    if (healthPercent <= 70 && !lightCracksShown) {
        createCrack(lastClickPosition.x, lastClickPosition.y, 'light');
        lightCracksShown = true;
    }
    
    if (healthPercent <= 30 && !heavyCracksShown) {
        createCrack(lastClickPosition.x, lastClickPosition.y, 'heavy');
        heavyCracksShown = true;
    }
    
    updateHealthBar();
    
    if (currentHealth <= 0) {
        isImageBreaking = true;
        
        setTimeout(() => {
            clearCracks();
            createFragmentsFromCracks(img, selectedTool);
            
            img.style.transition = 'none';
            img.style.visibility = 'hidden';
            
            imageQueue.shift();
            totalDestroyed++;
            
            setTimeout(() => {
                animateBoxTransition();
            }, 960);
            
            if (imageQueue.length > 0) {
                setTimeout(() => {
                    img.style.visibility = 'visible';
                    img.style.transition = 'filter 0.3s ease';
                    lightCracksShown = false;
                    heavyCracksShown = false;
                    isImageBreaking = false;
                    loadNextImage();
                    setTimeout(updateBoxQueuePosition, 350);
                }, 1684);
            } else {
                setTimeout(() => {
                    endGame();
                }, 1600);
            }
        }, 100);
    }
    
    canAttack = false;
    setTimeout(() => {
        canAttack = true;
    }, toolStats[selectedTool].cooldown);
}

function getRank(time, count) {
    const timeInSeconds = time / 1000;
    const avgTimePerImage = timeInSeconds / count;
    
    if (avgTimePerImage < 2) return 'S';
    if (avgTimePerImage < 3) return 'A';
    if (avgTimePerImage < 4) return 'B';
    if (avgTimePerImage < 5) return 'C';
    return 'D';
}

function endGame() {
    clearInterval(timerInterval);
    
    const finalTime = Date.now() - startTime;
    const seconds = Math.floor(finalTime / 1000);
    const milliseconds = Math.floor((finalTime % 1000) / 10);
    const formattedTime = `${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(2, '0')}`;
    
    document.getElementById('final-time').textContent = formattedTime;
    document.getElementById('final-count').textContent = totalDestroyed;
    document.getElementById('final-rank').textContent = getRank(finalTime, totalDestroyed);
    
    document.getElementById('game-container').classList.remove('visible');
    document.getElementById('box-queue-container').classList.remove('visible');
    document.querySelector('.timer').classList.remove('visible');
    document.querySelector('.current-label').classList.remove('visible');
    document.querySelector('.bottom-marquee-container').classList.remove('visible');
    document.getElementById('results-container').classList.add('visible');
}

document.getElementById('start-button').addEventListener('click', () => {
    document.querySelector('.timer').classList.add('visible');
    document.querySelector('.current-label').classList.add('visible');
    document.querySelector('.bottom-marquee-container').classList.add('visible');
    document.getElementById('instructions-container').classList.remove('visible');
    document.getElementById('game-container').classList.add('visible');
    document.getElementById('box-queue-container').classList.add('visible');
    
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 10);
    updateTimer();
    
    initializeBoxQueue();
    loadNextImage();
    setImageCursor();
    
    setTimeout(updateBoxQueuePosition, 100);
});

document.getElementById('current-image').addEventListener('click', attackImage);

document.querySelectorAll('.tool-icon').forEach(icon => {
    icon.addEventListener('click', () => {
        const newTool = icon.dataset.tool;
        selectedTool = newTool;
        
        document.querySelectorAll('.tool-icon').forEach(i => {
            const toolType = i.dataset.tool;
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const mode = isDarkMode ? 'dark' : 'light';
            if (i === icon) {
                i.src = `img/${toolType}_${mode}.webp`;
            } else {
                i.src = `img/${toolType}.webp`;
            }
        });
        setImageCursor();
    });
});

document.getElementById('restart-button').addEventListener('click', () => {
    window.location.href = 'https://gab333t.github.io/fuckno/';
});

document.getElementById('return-button').addEventListener('click', () => {
    window.location.href = 'https://gab333t.github.io/fuckno/';
});

document.getElementById('current-image').addEventListener('contextmenu', (e) => {
    e.preventDefault();
});
</script>
</body>
</html>